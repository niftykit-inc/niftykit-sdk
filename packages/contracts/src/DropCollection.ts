/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
    BaseContract,
    BigNumber,
    BigNumberish,
    BytesLike,
    CallOverrides,
    ContractTransaction,
    Overrides,
    PayableOverrides,
    PopulatedTransaction,
    Signer,
    utils,
  } from "ethers";
  import type {
    FunctionFragment,
    Result,
    EventFragment,
  } from "@ethersproject/abi";
  import type { Listener, Provider } from "@ethersproject/providers";
  import type {
    TypedEventFilter,
    TypedEvent,
    TypedListener,
    OnEvent,
  } from "./common";
  
  export declare namespace IERC721AUpgradeable {
    export type TokenOwnershipStruct = {
      addr: string;
      startTimestamp: BigNumberish;
      burned: boolean;
      extraData: BigNumberish;
    };
  
    export type TokenOwnershipStructOutput = [
      string,
      BigNumber,
      boolean,
      number
    ] & {
      addr: string;
      startTimestamp: BigNumber;
      burned: boolean;
      extraData: number;
    };
  }
  
  export interface DropCollectionInterface extends utils.Interface {
    functions: {
      "approve(address,uint256)": FunctionFragment;
      "balanceOf(address)": FunctionFragment;
      "batchAirdrop(uint64[],address[])": FunctionFragment;
      "explicitOwnershipOf(uint256)": FunctionFragment;
      "explicitOwnershipsOf(uint256[])": FunctionFragment;
      "getApproved(uint256)": FunctionFragment;
      "initialize(string,string,address,address,uint96)": FunctionFragment;
      "isApprovedForAll(address,address)": FunctionFragment;
      "maxAmount()": FunctionFragment;
      "maxPerMint()": FunctionFragment;
      "maxPerWallet()": FunctionFragment;
      "mint(uint64)": FunctionFragment;
      "mintTo(address,uint64)": FunctionFragment;
      "name()": FunctionFragment;
      "owner()": FunctionFragment;
      "ownerOf(uint256)": FunctionFragment;
      "presaleActive()": FunctionFragment;
      "presaleMint(uint64,uint256,bytes32[])": FunctionFragment;
      "presaleMintTo(address,uint64,uint256,bytes32[])": FunctionFragment;
      "price()": FunctionFragment;
      "renounceOwnership()": FunctionFragment;
      "royaltyInfo(uint256,uint256)": FunctionFragment;
      "safeTransferFrom(address,address,uint256)": FunctionFragment;
      "safeTransferFrom(address,address,uint256,bytes)": FunctionFragment;
      "saleActive()": FunctionFragment;
      "setApprovalForAll(address,bool)": FunctionFragment;
      "setBaseURI(string)": FunctionFragment;
      "setDefaultRoyalty(address,uint96)": FunctionFragment;
      "setMerkleRoot(bytes32)": FunctionFragment;
      "setTokenRoyalty(uint256,address,uint96)": FunctionFragment;
      "setTreasury(address)": FunctionFragment;
      "startSale(uint256,uint256,uint256,uint256,bool)": FunctionFragment;
      "stopSale()": FunctionFragment;
      "supportsInterface(bytes4)": FunctionFragment;
      "symbol()": FunctionFragment;
      "tokenURI(uint256)": FunctionFragment;
      "tokensOfOwner(address)": FunctionFragment;
      "tokensOfOwnerIn(address,uint256,uint256)": FunctionFragment;
      "totalRevenue()": FunctionFragment;
      "totalSupply()": FunctionFragment;
      "transferFrom(address,address,uint256)": FunctionFragment;
      "transferOwnership(address)": FunctionFragment;
      "treasury()": FunctionFragment;
      "withdraw()": FunctionFragment;
    };
  
    getFunction(
      nameOrSignatureOrTopic:
        | "approve"
        | "balanceOf"
        | "batchAirdrop"
        | "explicitOwnershipOf"
        | "explicitOwnershipsOf"
        | "getApproved"
        | "initialize"
        | "isApprovedForAll"
        | "maxAmount"
        | "maxPerMint"
        | "maxPerWallet"
        | "mint"
        | "mintTo"
        | "name"
        | "owner"
        | "ownerOf"
        | "presaleActive"
        | "presaleMint"
        | "presaleMintTo"
        | "price"
        | "renounceOwnership"
        | "royaltyInfo"
        | "safeTransferFrom(address,address,uint256)"
        | "safeTransferFrom(address,address,uint256,bytes)"
        | "saleActive"
        | "setApprovalForAll"
        | "setBaseURI"
        | "setDefaultRoyalty"
        | "setMerkleRoot"
        | "setTokenRoyalty"
        | "setTreasury"
        | "startSale"
        | "stopSale"
        | "supportsInterface"
        | "symbol"
        | "tokenURI"
        | "tokensOfOwner"
        | "tokensOfOwnerIn"
        | "totalRevenue"
        | "totalSupply"
        | "transferFrom"
        | "transferOwnership"
        | "treasury"
        | "withdraw"
    ): FunctionFragment;
  
    encodeFunctionData(
      functionFragment: "approve",
      values: [string, BigNumberish]
    ): string;
    encodeFunctionData(functionFragment: "balanceOf", values: [string]): string;
    encodeFunctionData(
      functionFragment: "batchAirdrop",
      values: [BigNumberish[], string[]]
    ): string;
    encodeFunctionData(
      functionFragment: "explicitOwnershipOf",
      values: [BigNumberish]
    ): string;
    encodeFunctionData(
      functionFragment: "explicitOwnershipsOf",
      values: [BigNumberish[]]
    ): string;
    encodeFunctionData(
      functionFragment: "getApproved",
      values: [BigNumberish]
    ): string;
    encodeFunctionData(
      functionFragment: "initialize",
      values: [string, string, string, string, BigNumberish]
    ): string;
    encodeFunctionData(
      functionFragment: "isApprovedForAll",
      values: [string, string]
    ): string;
    encodeFunctionData(functionFragment: "maxAmount", values?: undefined): string;
    encodeFunctionData(
      functionFragment: "maxPerMint",
      values?: undefined
    ): string;
    encodeFunctionData(
      functionFragment: "maxPerWallet",
      values?: undefined
    ): string;
    encodeFunctionData(functionFragment: "mint", values: [BigNumberish]): string;
    encodeFunctionData(
      functionFragment: "mintTo",
      values: [string, BigNumberish]
    ): string;
    encodeFunctionData(functionFragment: "name", values?: undefined): string;
    encodeFunctionData(functionFragment: "owner", values?: undefined): string;
    encodeFunctionData(
      functionFragment: "ownerOf",
      values: [BigNumberish]
    ): string;
    encodeFunctionData(
      functionFragment: "presaleActive",
      values?: undefined
    ): string;
    encodeFunctionData(
      functionFragment: "presaleMint",
      values: [BigNumberish, BigNumberish, BytesLike[]]
    ): string;
    encodeFunctionData(
      functionFragment: "presaleMintTo",
      values: [string, BigNumberish, BigNumberish, BytesLike[]]
    ): string;
    encodeFunctionData(functionFragment: "price", values?: undefined): string;
    encodeFunctionData(
      functionFragment: "renounceOwnership",
      values?: undefined
    ): string;
    encodeFunctionData(
      functionFragment: "royaltyInfo",
      values: [BigNumberish, BigNumberish]
    ): string;
    encodeFunctionData(
      functionFragment: "safeTransferFrom(address,address,uint256)",
      values: [string, string, BigNumberish]
    ): string;
    encodeFunctionData(
      functionFragment: "safeTransferFrom(address,address,uint256,bytes)",
      values: [string, string, BigNumberish, BytesLike]
    ): string;
    encodeFunctionData(
      functionFragment: "saleActive",
      values?: undefined
    ): string;
    encodeFunctionData(
      functionFragment: "setApprovalForAll",
      values: [string, boolean]
    ): string;
    encodeFunctionData(functionFragment: "setBaseURI", values: [string]): string;
    encodeFunctionData(
      functionFragment: "setDefaultRoyalty",
      values: [string, BigNumberish]
    ): string;
    encodeFunctionData(
      functionFragment: "setMerkleRoot",
      values: [BytesLike]
    ): string;
    encodeFunctionData(
      functionFragment: "setTokenRoyalty",
      values: [BigNumberish, string, BigNumberish]
    ): string;
    encodeFunctionData(functionFragment: "setTreasury", values: [string]): string;
    encodeFunctionData(
      functionFragment: "startSale",
      values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish, boolean]
    ): string;
    encodeFunctionData(functionFragment: "stopSale", values?: undefined): string;
    encodeFunctionData(
      functionFragment: "supportsInterface",
      values: [BytesLike]
    ): string;
    encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
    encodeFunctionData(
      functionFragment: "tokenURI",
      values: [BigNumberish]
    ): string;
    encodeFunctionData(
      functionFragment: "tokensOfOwner",
      values: [string]
    ): string;
    encodeFunctionData(
      functionFragment: "tokensOfOwnerIn",
      values: [string, BigNumberish, BigNumberish]
    ): string;
    encodeFunctionData(
      functionFragment: "totalRevenue",
      values?: undefined
    ): string;
    encodeFunctionData(
      functionFragment: "totalSupply",
      values?: undefined
    ): string;
    encodeFunctionData(
      functionFragment: "transferFrom",
      values: [string, string, BigNumberish]
    ): string;
    encodeFunctionData(
      functionFragment: "transferOwnership",
      values: [string]
    ): string;
    encodeFunctionData(functionFragment: "treasury", values?: undefined): string;
    encodeFunctionData(functionFragment: "withdraw", values?: undefined): string;
  
    decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
    decodeFunctionResult(
      functionFragment: "batchAirdrop",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "explicitOwnershipOf",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "explicitOwnershipsOf",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "getApproved",
      data: BytesLike
    ): Result;
    decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
    decodeFunctionResult(
      functionFragment: "isApprovedForAll",
      data: BytesLike
    ): Result;
    decodeFunctionResult(functionFragment: "maxAmount", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "maxPerMint", data: BytesLike): Result;
    decodeFunctionResult(
      functionFragment: "maxPerWallet",
      data: BytesLike
    ): Result;
    decodeFunctionResult(functionFragment: "mint", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "mintTo", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "ownerOf", data: BytesLike): Result;
    decodeFunctionResult(
      functionFragment: "presaleActive",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "presaleMint",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "presaleMintTo",
      data: BytesLike
    ): Result;
    decodeFunctionResult(functionFragment: "price", data: BytesLike): Result;
    decodeFunctionResult(
      functionFragment: "renounceOwnership",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "royaltyInfo",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "safeTransferFrom(address,address,uint256)",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "safeTransferFrom(address,address,uint256,bytes)",
      data: BytesLike
    ): Result;
    decodeFunctionResult(functionFragment: "saleActive", data: BytesLike): Result;
    decodeFunctionResult(
      functionFragment: "setApprovalForAll",
      data: BytesLike
    ): Result;
    decodeFunctionResult(functionFragment: "setBaseURI", data: BytesLike): Result;
    decodeFunctionResult(
      functionFragment: "setDefaultRoyalty",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "setMerkleRoot",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "setTokenRoyalty",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "setTreasury",
      data: BytesLike
    ): Result;
    decodeFunctionResult(functionFragment: "startSale", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "stopSale", data: BytesLike): Result;
    decodeFunctionResult(
      functionFragment: "supportsInterface",
      data: BytesLike
    ): Result;
    decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "tokenURI", data: BytesLike): Result;
    decodeFunctionResult(
      functionFragment: "tokensOfOwner",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "tokensOfOwnerIn",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "totalRevenue",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "totalSupply",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "transferFrom",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "transferOwnership",
      data: BytesLike
    ): Result;
    decodeFunctionResult(functionFragment: "treasury", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
  
    events: {
      "Approval(address,address,uint256)": EventFragment;
      "ApprovalForAll(address,address,bool)": EventFragment;
      "ConsecutiveTransfer(uint256,uint256,address,address)": EventFragment;
      "Initialized(uint8)": EventFragment;
      "OwnershipTransferred(address,address)": EventFragment;
      "Transfer(address,address,uint256)": EventFragment;
    };
  
    getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ApprovalForAll"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ConsecutiveTransfer"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
  }
  
  export interface ApprovalEventObject {
    owner: string;
    approved: string;
    tokenId: BigNumber;
  }
  export type ApprovalEvent = TypedEvent<
    [string, string, BigNumber],
    ApprovalEventObject
  >;
  
  export type ApprovalEventFilter = TypedEventFilter<ApprovalEvent>;
  
  export interface ApprovalForAllEventObject {
    owner: string;
    operator: string;
    approved: boolean;
  }
  export type ApprovalForAllEvent = TypedEvent<
    [string, string, boolean],
    ApprovalForAllEventObject
  >;
  
  export type ApprovalForAllEventFilter = TypedEventFilter<ApprovalForAllEvent>;
  
  export interface ConsecutiveTransferEventObject {
    fromTokenId: BigNumber;
    toTokenId: BigNumber;
    from: string;
    to: string;
  }
  export type ConsecutiveTransferEvent = TypedEvent<
    [BigNumber, BigNumber, string, string],
    ConsecutiveTransferEventObject
  >;
  
  export type ConsecutiveTransferEventFilter =
    TypedEventFilter<ConsecutiveTransferEvent>;
  
  export interface InitializedEventObject {
    version: number;
  }
  export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;
  
  export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;
  
  export interface OwnershipTransferredEventObject {
    previousOwner: string;
    newOwner: string;
  }
  export type OwnershipTransferredEvent = TypedEvent<
    [string, string],
    OwnershipTransferredEventObject
  >;
  
  export type OwnershipTransferredEventFilter =
    TypedEventFilter<OwnershipTransferredEvent>;
  
  export interface TransferEventObject {
    from: string;
    to: string;
    tokenId: BigNumber;
  }
  export type TransferEvent = TypedEvent<
    [string, string, BigNumber],
    TransferEventObject
  >;
  
  export type TransferEventFilter = TypedEventFilter<TransferEvent>;
  
  export interface DropCollection extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
  
    interface: DropCollectionInterface;
  
    queryFilter<TEvent extends TypedEvent>(
      event: TypedEventFilter<TEvent>,
      fromBlockOrBlockhash?: string | number | undefined,
      toBlock?: string | number | undefined
    ): Promise<Array<TEvent>>;
  
    listeners<TEvent extends TypedEvent>(
      eventFilter?: TypedEventFilter<TEvent>
    ): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(
      eventFilter: TypedEventFilter<TEvent>
    ): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
  
    functions: {
      approve(
        to: string,
        tokenId: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      balanceOf(owner: string, overrides?: CallOverrides): Promise<[BigNumber]>;
  
      batchAirdrop(
        quantities: BigNumberish[],
        recipients: string[],
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      explicitOwnershipOf(
        tokenId: BigNumberish,
        overrides?: CallOverrides
      ): Promise<[IERC721AUpgradeable.TokenOwnershipStructOutput]>;
  
      explicitOwnershipsOf(
        tokenIds: BigNumberish[],
        overrides?: CallOverrides
      ): Promise<[IERC721AUpgradeable.TokenOwnershipStructOutput[]]>;
  
      getApproved(
        tokenId: BigNumberish,
        overrides?: CallOverrides
      ): Promise<[string]>;
  
      initialize(
        name_: string,
        symbol_: string,
        treasury_: string,
        royalty_: string,
        royaltyFee_: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      isApprovedForAll(
        owner: string,
        operator: string,
        overrides?: CallOverrides
      ): Promise<[boolean]>;
  
      maxAmount(overrides?: CallOverrides): Promise<[BigNumber]>;
  
      maxPerMint(overrides?: CallOverrides): Promise<[BigNumber]>;
  
      maxPerWallet(overrides?: CallOverrides): Promise<[BigNumber]>;
  
      mint(
        quantity: BigNumberish,
        overrides?: PayableOverrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      mintTo(
        recipient: string,
        quantity: BigNumberish,
        overrides?: PayableOverrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      name(overrides?: CallOverrides): Promise<[string]>;
  
      owner(overrides?: CallOverrides): Promise<[string]>;
  
      ownerOf(
        tokenId: BigNumberish,
        overrides?: CallOverrides
      ): Promise<[string]>;
  
      presaleActive(overrides?: CallOverrides): Promise<[boolean]>;
  
      presaleMint(
        quantity: BigNumberish,
        allowed: BigNumberish,
        proof: BytesLike[],
        overrides?: PayableOverrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      presaleMintTo(
        recipient: string,
        quantity: BigNumberish,
        allowed: BigNumberish,
        proof: BytesLike[],
        overrides?: PayableOverrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      price(overrides?: CallOverrides): Promise<[BigNumber]>;
  
      renounceOwnership(
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      royaltyInfo(
        _tokenId: BigNumberish,
        _salePrice: BigNumberish,
        overrides?: CallOverrides
      ): Promise<[string, BigNumber]>;
  
      "safeTransferFrom(address,address,uint256)"(
        from: string,
        to: string,
        tokenId: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      "safeTransferFrom(address,address,uint256,bytes)"(
        from: string,
        to: string,
        tokenId: BigNumberish,
        _data: BytesLike,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      saleActive(overrides?: CallOverrides): Promise<[boolean]>;
  
      setApprovalForAll(
        operator: string,
        approved: boolean,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      setBaseURI(
        newBaseURI: string,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      setDefaultRoyalty(
        receiver: string,
        feeNumerator: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      setMerkleRoot(
        newRoot: BytesLike,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      setTokenRoyalty(
        tokenId: BigNumberish,
        receiver: string,
        feeNumerator: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      setTreasury(
        newTreasury: string,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      startSale(
        newMaxAmount: BigNumberish,
        newMaxPerMint: BigNumberish,
        newMaxPerWallet: BigNumberish,
        newPrice: BigNumberish,
        presale: boolean,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      stopSale(
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      supportsInterface(
        interfaceId: BytesLike,
        overrides?: CallOverrides
      ): Promise<[boolean]>;
  
      symbol(overrides?: CallOverrides): Promise<[string]>;
  
      tokenURI(
        tokenId: BigNumberish,
        overrides?: CallOverrides
      ): Promise<[string]>;
  
      tokensOfOwner(
        owner: string,
        overrides?: CallOverrides
      ): Promise<[BigNumber[]]>;
  
      tokensOfOwnerIn(
        owner: string,
        start: BigNumberish,
        stop: BigNumberish,
        overrides?: CallOverrides
      ): Promise<[BigNumber[]]>;
  
      totalRevenue(overrides?: CallOverrides): Promise<[BigNumber]>;
  
      totalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;
  
      transferFrom(
        from: string,
        to: string,
        tokenId: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      transferOwnership(
        newOwner: string,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      treasury(overrides?: CallOverrides): Promise<[string]>;
  
      withdraw(
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
    };
  
    approve(
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    balanceOf(owner: string, overrides?: CallOverrides): Promise<BigNumber>;
  
    batchAirdrop(
      quantities: BigNumberish[],
      recipients: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    explicitOwnershipOf(
      tokenId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<IERC721AUpgradeable.TokenOwnershipStructOutput>;
  
    explicitOwnershipsOf(
      tokenIds: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<IERC721AUpgradeable.TokenOwnershipStructOutput[]>;
  
    getApproved(
      tokenId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;
  
    initialize(
      name_: string,
      symbol_: string,
      treasury_: string,
      royalty_: string,
      royaltyFee_: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    isApprovedForAll(
      owner: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<boolean>;
  
    maxAmount(overrides?: CallOverrides): Promise<BigNumber>;
  
    maxPerMint(overrides?: CallOverrides): Promise<BigNumber>;
  
    maxPerWallet(overrides?: CallOverrides): Promise<BigNumber>;
  
    mint(
      quantity: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    mintTo(
      recipient: string,
      quantity: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    name(overrides?: CallOverrides): Promise<string>;
  
    owner(overrides?: CallOverrides): Promise<string>;
  
    ownerOf(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;
  
    presaleActive(overrides?: CallOverrides): Promise<boolean>;
  
    presaleMint(
      quantity: BigNumberish,
      allowed: BigNumberish,
      proof: BytesLike[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    presaleMintTo(
      recipient: string,
      quantity: BigNumberish,
      allowed: BigNumberish,
      proof: BytesLike[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    price(overrides?: CallOverrides): Promise<BigNumber>;
  
    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    royaltyInfo(
      _tokenId: BigNumberish,
      _salePrice: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string, BigNumber]>;
  
    "safeTransferFrom(address,address,uint256)"(
      from: string,
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    "safeTransferFrom(address,address,uint256,bytes)"(
      from: string,
      to: string,
      tokenId: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    saleActive(overrides?: CallOverrides): Promise<boolean>;
  
    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    setBaseURI(
      newBaseURI: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    setDefaultRoyalty(
      receiver: string,
      feeNumerator: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    setMerkleRoot(
      newRoot: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    setTokenRoyalty(
      tokenId: BigNumberish,
      receiver: string,
      feeNumerator: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    setTreasury(
      newTreasury: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    startSale(
      newMaxAmount: BigNumberish,
      newMaxPerMint: BigNumberish,
      newMaxPerWallet: BigNumberish,
      newPrice: BigNumberish,
      presale: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    stopSale(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;
  
    symbol(overrides?: CallOverrides): Promise<string>;
  
    tokenURI(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;
  
    tokensOfOwner(owner: string, overrides?: CallOverrides): Promise<BigNumber[]>;
  
    tokensOfOwnerIn(
      owner: string,
      start: BigNumberish,
      stop: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;
  
    totalRevenue(overrides?: CallOverrides): Promise<BigNumber>;
  
    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;
  
    transferFrom(
      from: string,
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    treasury(overrides?: CallOverrides): Promise<string>;
  
    withdraw(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    callStatic: {
      approve(
        to: string,
        tokenId: BigNumberish,
        overrides?: CallOverrides
      ): Promise<void>;
  
      balanceOf(owner: string, overrides?: CallOverrides): Promise<BigNumber>;
  
      batchAirdrop(
        quantities: BigNumberish[],
        recipients: string[],
        overrides?: CallOverrides
      ): Promise<void>;
  
      explicitOwnershipOf(
        tokenId: BigNumberish,
        overrides?: CallOverrides
      ): Promise<IERC721AUpgradeable.TokenOwnershipStructOutput>;
  
      explicitOwnershipsOf(
        tokenIds: BigNumberish[],
        overrides?: CallOverrides
      ): Promise<IERC721AUpgradeable.TokenOwnershipStructOutput[]>;
  
      getApproved(
        tokenId: BigNumberish,
        overrides?: CallOverrides
      ): Promise<string>;
  
      initialize(
        name_: string,
        symbol_: string,
        treasury_: string,
        royalty_: string,
        royaltyFee_: BigNumberish,
        overrides?: CallOverrides
      ): Promise<void>;
  
      isApprovedForAll(
        owner: string,
        operator: string,
        overrides?: CallOverrides
      ): Promise<boolean>;
  
      maxAmount(overrides?: CallOverrides): Promise<BigNumber>;
  
      maxPerMint(overrides?: CallOverrides): Promise<BigNumber>;
  
      maxPerWallet(overrides?: CallOverrides): Promise<BigNumber>;
  
      mint(quantity: BigNumberish, overrides?: CallOverrides): Promise<void>;
  
      mintTo(
        recipient: string,
        quantity: BigNumberish,
        overrides?: CallOverrides
      ): Promise<void>;
  
      name(overrides?: CallOverrides): Promise<string>;
  
      owner(overrides?: CallOverrides): Promise<string>;
  
      ownerOf(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;
  
      presaleActive(overrides?: CallOverrides): Promise<boolean>;
  
      presaleMint(
        quantity: BigNumberish,
        allowed: BigNumberish,
        proof: BytesLike[],
        overrides?: CallOverrides
      ): Promise<void>;
  
      presaleMintTo(
        recipient: string,
        quantity: BigNumberish,
        allowed: BigNumberish,
        proof: BytesLike[],
        overrides?: CallOverrides
      ): Promise<void>;
  
      price(overrides?: CallOverrides): Promise<BigNumber>;
  
      renounceOwnership(overrides?: CallOverrides): Promise<void>;
  
      royaltyInfo(
        _tokenId: BigNumberish,
        _salePrice: BigNumberish,
        overrides?: CallOverrides
      ): Promise<[string, BigNumber]>;
  
      "safeTransferFrom(address,address,uint256)"(
        from: string,
        to: string,
        tokenId: BigNumberish,
        overrides?: CallOverrides
      ): Promise<void>;
  
      "safeTransferFrom(address,address,uint256,bytes)"(
        from: string,
        to: string,
        tokenId: BigNumberish,
        _data: BytesLike,
        overrides?: CallOverrides
      ): Promise<void>;
  
      saleActive(overrides?: CallOverrides): Promise<boolean>;
  
      setApprovalForAll(
        operator: string,
        approved: boolean,
        overrides?: CallOverrides
      ): Promise<void>;
  
      setBaseURI(newBaseURI: string, overrides?: CallOverrides): Promise<void>;
  
      setDefaultRoyalty(
        receiver: string,
        feeNumerator: BigNumberish,
        overrides?: CallOverrides
      ): Promise<void>;
  
      setMerkleRoot(newRoot: BytesLike, overrides?: CallOverrides): Promise<void>;
  
      setTokenRoyalty(
        tokenId: BigNumberish,
        receiver: string,
        feeNumerator: BigNumberish,
        overrides?: CallOverrides
      ): Promise<void>;
  
      setTreasury(newTreasury: string, overrides?: CallOverrides): Promise<void>;
  
      startSale(
        newMaxAmount: BigNumberish,
        newMaxPerMint: BigNumberish,
        newMaxPerWallet: BigNumberish,
        newPrice: BigNumberish,
        presale: boolean,
        overrides?: CallOverrides
      ): Promise<void>;
  
      stopSale(overrides?: CallOverrides): Promise<void>;
  
      supportsInterface(
        interfaceId: BytesLike,
        overrides?: CallOverrides
      ): Promise<boolean>;
  
      symbol(overrides?: CallOverrides): Promise<string>;
  
      tokenURI(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;
  
      tokensOfOwner(
        owner: string,
        overrides?: CallOverrides
      ): Promise<BigNumber[]>;
  
      tokensOfOwnerIn(
        owner: string,
        start: BigNumberish,
        stop: BigNumberish,
        overrides?: CallOverrides
      ): Promise<BigNumber[]>;
  
      totalRevenue(overrides?: CallOverrides): Promise<BigNumber>;
  
      totalSupply(overrides?: CallOverrides): Promise<BigNumber>;
  
      transferFrom(
        from: string,
        to: string,
        tokenId: BigNumberish,
        overrides?: CallOverrides
      ): Promise<void>;
  
      transferOwnership(
        newOwner: string,
        overrides?: CallOverrides
      ): Promise<void>;
  
      treasury(overrides?: CallOverrides): Promise<string>;
  
      withdraw(overrides?: CallOverrides): Promise<void>;
    };
  
    filters: {
      "Approval(address,address,uint256)"(
        owner?: string | null,
        approved?: string | null,
        tokenId?: BigNumberish | null
      ): ApprovalEventFilter;
      Approval(
        owner?: string | null,
        approved?: string | null,
        tokenId?: BigNumberish | null
      ): ApprovalEventFilter;
  
      "ApprovalForAll(address,address,bool)"(
        owner?: string | null,
        operator?: string | null,
        approved?: null
      ): ApprovalForAllEventFilter;
      ApprovalForAll(
        owner?: string | null,
        operator?: string | null,
        approved?: null
      ): ApprovalForAllEventFilter;
  
      "ConsecutiveTransfer(uint256,uint256,address,address)"(
        fromTokenId?: BigNumberish | null,
        toTokenId?: null,
        from?: string | null,
        to?: string | null
      ): ConsecutiveTransferEventFilter;
      ConsecutiveTransfer(
        fromTokenId?: BigNumberish | null,
        toTokenId?: null,
        from?: string | null,
        to?: string | null
      ): ConsecutiveTransferEventFilter;
  
      "Initialized(uint8)"(version?: null): InitializedEventFilter;
      Initialized(version?: null): InitializedEventFilter;
  
      "OwnershipTransferred(address,address)"(
        previousOwner?: string | null,
        newOwner?: string | null
      ): OwnershipTransferredEventFilter;
      OwnershipTransferred(
        previousOwner?: string | null,
        newOwner?: string | null
      ): OwnershipTransferredEventFilter;
  
      "Transfer(address,address,uint256)"(
        from?: string | null,
        to?: string | null,
        tokenId?: BigNumberish | null
      ): TransferEventFilter;
      Transfer(
        from?: string | null,
        to?: string | null,
        tokenId?: BigNumberish | null
      ): TransferEventFilter;
    };
  
    estimateGas: {
      approve(
        to: string,
        tokenId: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      balanceOf(owner: string, overrides?: CallOverrides): Promise<BigNumber>;
  
      batchAirdrop(
        quantities: BigNumberish[],
        recipients: string[],
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      explicitOwnershipOf(
        tokenId: BigNumberish,
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      explicitOwnershipsOf(
        tokenIds: BigNumberish[],
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      getApproved(
        tokenId: BigNumberish,
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      initialize(
        name_: string,
        symbol_: string,
        treasury_: string,
        royalty_: string,
        royaltyFee_: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      isApprovedForAll(
        owner: string,
        operator: string,
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      maxAmount(overrides?: CallOverrides): Promise<BigNumber>;
  
      maxPerMint(overrides?: CallOverrides): Promise<BigNumber>;
  
      maxPerWallet(overrides?: CallOverrides): Promise<BigNumber>;
  
      mint(
        quantity: BigNumberish,
        overrides?: PayableOverrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      mintTo(
        recipient: string,
        quantity: BigNumberish,
        overrides?: PayableOverrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      name(overrides?: CallOverrides): Promise<BigNumber>;
  
      owner(overrides?: CallOverrides): Promise<BigNumber>;
  
      ownerOf(
        tokenId: BigNumberish,
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      presaleActive(overrides?: CallOverrides): Promise<BigNumber>;
  
      presaleMint(
        quantity: BigNumberish,
        allowed: BigNumberish,
        proof: BytesLike[],
        overrides?: PayableOverrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      presaleMintTo(
        recipient: string,
        quantity: BigNumberish,
        allowed: BigNumberish,
        proof: BytesLike[],
        overrides?: PayableOverrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      price(overrides?: CallOverrides): Promise<BigNumber>;
  
      renounceOwnership(
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      royaltyInfo(
        _tokenId: BigNumberish,
        _salePrice: BigNumberish,
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      "safeTransferFrom(address,address,uint256)"(
        from: string,
        to: string,
        tokenId: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      "safeTransferFrom(address,address,uint256,bytes)"(
        from: string,
        to: string,
        tokenId: BigNumberish,
        _data: BytesLike,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      saleActive(overrides?: CallOverrides): Promise<BigNumber>;
  
      setApprovalForAll(
        operator: string,
        approved: boolean,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      setBaseURI(
        newBaseURI: string,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      setDefaultRoyalty(
        receiver: string,
        feeNumerator: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      setMerkleRoot(
        newRoot: BytesLike,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      setTokenRoyalty(
        tokenId: BigNumberish,
        receiver: string,
        feeNumerator: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      setTreasury(
        newTreasury: string,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      startSale(
        newMaxAmount: BigNumberish,
        newMaxPerMint: BigNumberish,
        newMaxPerWallet: BigNumberish,
        newPrice: BigNumberish,
        presale: boolean,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      stopSale(
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      supportsInterface(
        interfaceId: BytesLike,
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      symbol(overrides?: CallOverrides): Promise<BigNumber>;
  
      tokenURI(
        tokenId: BigNumberish,
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      tokensOfOwner(owner: string, overrides?: CallOverrides): Promise<BigNumber>;
  
      tokensOfOwnerIn(
        owner: string,
        start: BigNumberish,
        stop: BigNumberish,
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      totalRevenue(overrides?: CallOverrides): Promise<BigNumber>;
  
      totalSupply(overrides?: CallOverrides): Promise<BigNumber>;
  
      transferFrom(
        from: string,
        to: string,
        tokenId: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      transferOwnership(
        newOwner: string,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      treasury(overrides?: CallOverrides): Promise<BigNumber>;
  
      withdraw(
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
    };
  
    populateTransaction: {
      approve(
        to: string,
        tokenId: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      balanceOf(
        owner: string,
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      batchAirdrop(
        quantities: BigNumberish[],
        recipients: string[],
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      explicitOwnershipOf(
        tokenId: BigNumberish,
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      explicitOwnershipsOf(
        tokenIds: BigNumberish[],
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      getApproved(
        tokenId: BigNumberish,
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      initialize(
        name_: string,
        symbol_: string,
        treasury_: string,
        royalty_: string,
        royaltyFee_: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      isApprovedForAll(
        owner: string,
        operator: string,
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      maxAmount(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  
      maxPerMint(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  
      maxPerWallet(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  
      mint(
        quantity: BigNumberish,
        overrides?: PayableOverrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      mintTo(
        recipient: string,
        quantity: BigNumberish,
        overrides?: PayableOverrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      name(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  
      owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  
      ownerOf(
        tokenId: BigNumberish,
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      presaleActive(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  
      presaleMint(
        quantity: BigNumberish,
        allowed: BigNumberish,
        proof: BytesLike[],
        overrides?: PayableOverrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      presaleMintTo(
        recipient: string,
        quantity: BigNumberish,
        allowed: BigNumberish,
        proof: BytesLike[],
        overrides?: PayableOverrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      price(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  
      renounceOwnership(
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      royaltyInfo(
        _tokenId: BigNumberish,
        _salePrice: BigNumberish,
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      "safeTransferFrom(address,address,uint256)"(
        from: string,
        to: string,
        tokenId: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      "safeTransferFrom(address,address,uint256,bytes)"(
        from: string,
        to: string,
        tokenId: BigNumberish,
        _data: BytesLike,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      saleActive(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  
      setApprovalForAll(
        operator: string,
        approved: boolean,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      setBaseURI(
        newBaseURI: string,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      setDefaultRoyalty(
        receiver: string,
        feeNumerator: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      setMerkleRoot(
        newRoot: BytesLike,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      setTokenRoyalty(
        tokenId: BigNumberish,
        receiver: string,
        feeNumerator: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      setTreasury(
        newTreasury: string,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      startSale(
        newMaxAmount: BigNumberish,
        newMaxPerMint: BigNumberish,
        newMaxPerWallet: BigNumberish,
        newPrice: BigNumberish,
        presale: boolean,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      stopSale(
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      supportsInterface(
        interfaceId: BytesLike,
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  
      tokenURI(
        tokenId: BigNumberish,
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      tokensOfOwner(
        owner: string,
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      tokensOfOwnerIn(
        owner: string,
        start: BigNumberish,
        stop: BigNumberish,
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      totalRevenue(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  
      totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  
      transferFrom(
        from: string,
        to: string,
        tokenId: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      transferOwnership(
        newOwner: string,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      treasury(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  
      withdraw(
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
    };
  }